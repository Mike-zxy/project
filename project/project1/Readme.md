
# Project1: SM4 的实现和优化

## 1. 实现 SM4 算法

根据 SM4 算法的流程，我们实现了 **SM4 加密算法的常数定义、轮函数、S 盒、线性变换、非线性变换、密钥扩展等核心操作**，并进行了加解密的验证。

---

## 总体结构概述

本程序实现了国密算法 **SM4** 的基本加密过程，主要模块包括：

* SM4 的核心常量（FK、CK、S-Box）
* 密钥扩展函数 `sm4_key_expansion`
* 加密轮函数 `sm4_f`
* 辅助线性/非线性变换函数
* 单个 128-bit 数据块加密函数 `sm4_encrypt_block`

---

## 常量定义

### 2.1 FK（系统参数）

```c
static const uint32_t SM4_FK[4];
```

* 用于密钥扩展的初始常数（固定 4 个 32-bit 常量）
* 起到与用户密钥初步混淆的作用

### 2.2 CK（轮常数）

```c
static const uint32_t SM4_CK[32];
```

* 每轮密钥扩展用的轮常数
* 一共 32 个，每轮使用一个 `CK[i]`

### 2.3 S-Box（非线性变换）

```c
static const uint8_t SM4_SBOX[256];
```

* 非线性替代表，用于字节级替换
* 是抗差分/线性攻击的核心组件

---

## 辅助函数说明

### 3.1 循环左移函数

```c
static uint32_t rotl(uint32_t x, int n);
```

* 实现 32 位整数的循环左移
* 用于线性变换操作

### 3.2 非线性变换 τ（S-Box 替换）

```c
static uint32_t tau(uint32_t a);
```

* 将 32 位数据拆分成字节
* 使用 S-Box 对每个字节进行替换

### 3.3 线性变换 L 和 L'

```c
static uint32_t l_transform(uint32_t x);
static uint32_t l_prime_transform(uint32_t x);
```

* `L`：用于加密过程
* `L'`：用于密钥扩展过程
* 都用于增强数据的比特扩散性

---

## 轮函数 F

```c
static uint32_t sm4_f(uint32_t x0, x1, x2, x3, rk);
```

* SM4 的核心轮函数：

  ```
  F(x0, x1, x2, x3, rk) = x0 ^ L(tau(x1 ^ x2 ^ x3 ^ rk))
  ```

* 每轮对 128-bit 状态的一个 32-bit 分量进行更新

* 结构类似于 Feistel 网络

---

## 密钥扩展过程

```c
static void sm4_key_expansion(const uint8_t key[16], uint32_t rk[32]);
```

* 输入：128-bit 原始密钥（16 字节）
* 输出：32 个轮密钥 `rk[0..31]`
* 扩展流程如下：

1. 初始混淆：

   ```math
   K[0..3] = key[0..3] ^ FK[0..3]
   ```

2. 进行 32 轮扩展

3. 生成轮密钥：

   ```math
   rk[i] = K[i+4]
   ```

---

## 加密函数流程

```c
static void sm4_encrypt_block(const uint8_t plaintext[16], const uint8_t key[16], uint8_t ciphertext[16]);
```

### 输入：

* 明文：128-bit（16 字节）
* 密钥：128-bit（16 字节）

### 输出：

* 密文：128-bit（16 字节）

### 步骤：

1. 调用 `sm4_key_expansion` 生成轮密钥数组 `rk[32]`

2. 明文按字节划分为 4 个 32-bit 状态变量 `X[0..3]`

3. 进行 32 轮加密迭代：

   ```math
   X[i+4] = F(X[i], X[i+1], X[i+2], X[i+3], rk[i])
   ```

4. 拼接输出（逆序）：

   ```c
   ciphertext = X[35], X[34], X[33], X[32]
   ```

---

## 实验结果

### 测试密钥与明文：

![测试输入](https://github.com/user-attachments/assets/e5e570cf-5d67-49ed-a67f-35eebb59429e)

### 加密结果验证：

* 成功加密得到密文
* 解密后使用 `memcmp()` 验证，结果与明文一致

![验证输出](https://github.com/user-attachments/assets/08db7ddd-02c8-46ae-848a-5c3c7570906c)

---
## 2.SM4算法的优化

#### **1. 使用 T-Table（查找表）优化非线性变换 T(A)**

* SM4 的 T 变换由 S-Box 非线性变换 τ 和线性变换 L 组成，传统计算方式较慢。
* 该实现通过预先构造 `T_TABLE[4][256]`，将 T(A) = L(τ(A)) 映射为查表操作。
* 每次加密轮中，通过查表并使用异或操作组合结果，避免了运行时重复计算。

#### **2. 利用 AVX 指令集实现 128 位向量化处理**

* 使用 `__m128i` 类型和 `_mm_*` 系列指令，实现对 128 位数据块的并行处理。
* 加密和解密函数中通过 AVX 指令高效加载、重排、存储 block 数据，提高整体吞吐量。

#### **3. 状态变量循环优化**

* 原始算法中状态在每轮需要复制和移动。
* 本实现中使用局部数组 `state[4]` 以覆盖更新方式维护状态，避免了多余的内存操作。

#### **4. 轮密钥扩展（KeySchedule）使用优化后的 T' 变换**

* KeySchedule 中的 T' 变换采用 S-Box 查表 + 位移组合计算方式，提升效率。
* 使用左移与异或快速实现线性变换 L'，整体更高效。

---

### **总结**

该代码通过以下方式优化了 SM4 算法的性能：

* 使用查表方式替代复杂变换。
* 利用 SIMD（AVX）指令提升并行计算能力。
* 精简状态更新操作。
* 高效实现轮密钥扩展。


